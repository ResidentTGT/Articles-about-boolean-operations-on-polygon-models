# **Задача поиска пересечения многогранных тел, алгоритмы и структуры данных.**

## **1. Введение**

Обнаружение столкновений – это фундаментальная проблема во многих дисциплинах, включая компьютерную анимацию, виртуальную реальность, твердотельное моделирование и вычислительную геометрию. Даны два объекта, конкретно – две полигональные модели, цель – определить пересекаются ли они или нет.

Естественный подход, который заключается в тестировании примитивов одной модели на пересечение со всеми примитивами другой требует огромное количество тестов на пересечение (triangle-to-triangle). Т.о. многие алгоритмы были разработаны с целью уменьшить количество операций за счет использования иерархических структур данных. Все эти структуры данных значительно уменьшают количество тестов пересечений, однако на нижних уровнях иерархии такие тесты все равно должны выполняться.

Т.н. метод «грубой силы» или полного перебора для определения пересечения двух треугольников в трехмерном пространстве требует решения шести линейных уравнений, каждое из которых соответствует пересечению одного ребра треугольника с поверхностью другого. Были предложены более быстрые алгоритмы, которые находят линию пересечения двух треугольников. Мёллер (1998) предложил алгоритм, который основывается на скалярных проекциях вершин треугольников на эту линию. Хельд (1997) использовал метод, по которому сначала вычисляется линейный сегмент пересечения одного треугольника с этой линией, а затем этот сегмент проверяется на пересечение с ребрами другого треугольника. Оба метода в дальнейшем были усовершенствованы, чтобы получить более быстрые и надежные варианты решения задачи поиска пересечения. Один из алгоритмов, который являлся улучшением алгоритма Мёллера, был предложен Гигом и Девиллером (2004). Их метод опирается исключительно на вычисление ориентационных предикатов (определители 4х4) и не требует никаких вспомогательных конструкций.

Все перечисленные методы основаны на геометрическом решении задачи пересечения. Тропп и Шимшони (2005) предложили подойти к проблеме с точки зрения алгебры. Их метод основан на алгоритме полного перебора. Найдя связь в системах уравнений, они сильно упростили решение систем.

Для сложных объектов более эффективен подход, в основу которого положено постепенное продвижение к оболочке, внутри которой находится объект, путем усложняющегося разбиения окружающего пространства на простые ограничивающие объемы (чаще всего - параллелепипеды).

При этом проверка на пересечение простых многогранников, по-прежнему, производится «в лоб», то есть прямым перебором пар, но тотальная проверка пересечений сеток, описывающих объекты, заменяется на проверку пересечений ограничивающих объемов. Лишь на завершающих фазах (когда грани некоторых ограничивающих объемов близки к участкам возможного пересечения) осуществляется тотальная проверка пересечения только таких «вычисленных» участков сеток. В итоге, общее число проверок удается понизить благодаря использованию относительно небольшого числа простых по форме ограничивающих объемов.

Эффективность алгоритмов проверки столкновений, основанных на последовательном разбиении пространства, зависит от многих факторов: способа и порядка декомпозиции пространства, формы и ориентации ограничивающих объемов, формы самого объекта, способа оптимизации разбиения и т.д. Существует много подходов к повышению эффективности этих алгоритмов. Большинство из них сводится к поиску такого способа декомпозиции, при котором сильнее всего уменьшается число пар объектов или примитивов, которые нужно проверять на пересечение.

Октантные деревья, k-мерные и BSP-деревья (бинарные), тетраэдральные сетки, регулярные решетки - все это примеры различных механизмов декомпозиции пространства.

Разделяя пространство, занимаемое объектами, можно проверять контакт только между теми объектами или их частями, которые находятся внутри или около полученного в результате такого деления элемента пространства, что обеспечивает ускорение процесса проверки пересечений.

Конструируя иерархии объектов, можно добиваться аппроксимации объектов с возрастающей точностью, до тех пор, пока не будет достигнута их истинная геометрическая форма. В качестве аппроксимирующих пространств можно использовать сферы, диски, ориентированные вдоль осей координат параллелепипеды (axis - aligned bounding boxes - ААВВ), произвольно ориентированные параллелепипеды (oriented bounding boxes - OBB), дискретно-ориентированные многогранники с количеством k ограничивающих плоскостей (к-dop) (discrete orientation polytopes). Для того чтобы представить эти пространственные структуры, аппроксимирующие объекты, приведем их двумерные изображения (рис. 1).

| [<img src="./media/image1.png" width="339" height="318" />](https://github.com/ResidentTGT/Doc/blob/master/media/image1.png) |
|------------------------------------------------------------------------------------------------------------------------------|
| Рис.1. Аппроксимация объекта с помощью четырех пространственных структур: AABB(а); сферы(б); OBB(в); k-dop(k=8)(г) |

## **2. Структуры данных**

### **2.1 BSP-деревья (Naylor, 1990)**

Двоичное разбиение пространства — метод рекурсивного разбиения евклидова пространства в выпуклые множества и гиперплоскости. В результате объекты получают представление в виде структуры данных, называемой BSP-деревом.

В BSP-дереве каждый узел связан с разбивающей прямой или плоскостью(сплиттер) в 2-мерном или 3-мерном пространстве соответственно. При этом все объекты, лежащие спереди сплиттера относятся к переднему поддереву, а все объекты, лежащие за сплиттером относятся к заднему поддереву. Для определения принадлежности объекта относительно стороны сплиттера необходимо исследовать положение каждой его точки. Положение точки P относительно сплиттера определяется скалярным произведением нормали сплиттера и вектора, начинающегося на сплиттере и проходящего через точку P. Возможно три случая:

1) Скалярное произведение больше 0 — точка лежит перед сплиттером;

2) Скалярное произведение равно 0 — точка лежит на сплиттере;

3) Скалярное произведение меньше 0 — точка лежит за сплиттером.

Если для всех точек объекта скалярное произведение больше или равно 0, то он относится к переднему поддереву. Если для всех точек объекта скалярное произведение меньше или равно 0, то он относится к заднему поддереву. Если скалярные произведения для точек объекта имеют разный знак, то он рассекается сплиттером так, что полученные точки лежат по двум сторонам от сплиттера. Для каждого подузла BSP-дерева справедливо вышеприведенное утверждение, с тем исключением, что рассмотрению подлежат только те объекты, которые лежат с одной стороны от сплиттера родительского узла.

Как правило, BSP-дерево строится для набора отрезков на плоскости или полигонов в пространстве, представляющих некоторую фигуру или сцену. Рассмотрим алгоритм построения BSP-дерева для набора полигонов в пространстве:

1) Если заданное множество полигонов пустое, то закончить алгоритм;

2) Для заданного множества полигонов выбрать разбивающую плоскость (сплиттер) S;

3) Рассечь все полигоны, пересекающиеся с S;

4) Отнести все полигоны, находящиеся со стороны S, к переднему поддереву F, а все полигоны, находящиеся с другой стороны S, к заднему поддереву B;

5) Выполнить алгоритм рекурсивно для множества полигонов переднего поддерева F.

6) Выполнить алгоритм рекурсивно для множества полигонов заднего поддерева B.

Алгоритм выполняется до тех пор, пока в поддеревьях не будет более 1 полигона.

| <img src="./media/image2.png" width="409" height="351" /> |
|-----------------------------------------------------------|
| Рис.2. |

Разбивающая плоскость(сплиттер) выбирается таким образом, чтобы сбалансировать дерево, то есть чтобы число полигонов в переднем и заднем поддереве было приблизительно одинаково:

min (|N(Fi) — N(Bi)|)

где N(Fi) — число полигонов с одной стороны некоторой разбивающей плоскости i, N(Bi) — число полигонов с другой стороны разбивающей плоскости i.

### **2.2 Процедура построения квадрантного дерева.**

Сначала создаётся квадрат, в который многоугольник помещается целиком. Для этого находится максимальные и минимальные координаты по Х и по Y. Далее находится сторона квадрата и его центр. Этот квадрат называется корневым октантом. Затем корневой октант делится на 4 октанта, после чего анализируется их положение по отношению к многоугольнику. Если октант находится полностью внутри многоугольника, он считается «чёрным»; если снаружи – «белым». Если же октант частично лежит внутри многоугольника, а частично – снаружи, то он считается «серым» и делится на четыре октанта меньшего размера. Чёрные и белые октанты дальше не делятся. Процедура продолжается до тех пор, пока не будет достигнут заданный уровень разбиения. «Цвет» определяется следующим образом: проверяется, пересекаются ли стороны октанта со сторонами многоугольника. Если стороны октанта пересекаются со сторонами многоугольника, то октант считается «серым». Иначе октант лежит внутри либо снаружи многоугольника. Чтобы определить его «цвет» подсчитывается количество пересечений отрезка лежащего между центром октанта и одной из вершин корневого октанта со сторонами многоугольника. Если количество пересечений чётное или ноль, то квадрат лежит снаружи многоугольника и считается «белым». Иначе если количество пересечений нечётное, то он лежит внутри многоугольника и считается «чёрным». На чертеже рисуются только октанты внутри треугольника.

| <img src="./media/image3.jpeg" width="618" height="203" /> |
|------------------------------------------------------------|
| Рис.3. |

### **2.3 OBB-дерево**

OBB- это прямоугольный ограничивающий объём, ориентированный в трехмерном пространстве по осям, параллельным наибольшей и наименьшей сторонам объекта. Результирующая иерархическая структура – это т.н. «дерево» из таких OBB. В сравнении с другими иерархическими представлениями моделей (при помощи сфер и осе-ориентированных ограничивающих объемов OBB дают наибольшую точность модели и наивысшую скорость поиска пересечений между ними в случаях близкого расположения различных участков моделей.

| <img src="./media/image4.png" width="429" height="145" /> |
|-----------------------------------------------------------|
| Рис.4. Точность различных ограничивающих объемов (d-наибольшее расстояние от одного конца объекта к другому, ε – наибольшее отклонение от d по нормали) |

Конструкция дерева имеет две компоненты: 1) расположение охватывающих OBB среди полигонов; 2) объединение в группы OBB, входящих в иерархическое дерево.

| <img src="./media/image5.png" width="622" height="162" /> |
|-----------------------------------------------------------|
| Рис.5. Построение OBB-модели |

| <img src="./media/image6.png" width="345" height="245" /> |
|-----------------------------------------------------------|
| Рис.6. Дерево OBB-модели |

## **3. Алгоритмы нахождения пересечения**

### **3.1 [Алгоритм Мёллера (1998)](https://github.com/ResidentTGT/Doc/blob/master/A%20Fast%20Triangle-Triangle%20Intersection%20Test%20Moller.PDF)**

Введем два треугольника T<sub>1</sub> и T<sub>2</sub> с вершинами V<sub>0</sub><sup>1</sup> , V<sub>1</sub><sup>1</sup> , V<sub>2</sub><sup>1</sup> и V<sub>0</sub><sup>2</sup> , V<sub>1</sub><sup>2</sup> , V<sub>2</sub><sup>2</sup> (заданы векторами) соответственно и плоскости, в которых лежат треугольники π<sub>1</sub> и π<sub>2</sub>.

Уравнение плоскости π<sub>2</sub>: N<sub>2</sub>∙X+d<sub>2</sub>=0(где X - любая точка на плоскости, N<sub>2</sub>- нормаль плоскости π<sub>2</sub>) вычисляется:

<img src="./media/image7.png" width="183" height="44" />

Подставив вершины в уравнение плоскости, вычисляются расстояния (с учетом знака) от вершин треугольника T<sub>1</sub> до плоскости π<sub>2</sub>:

<img src="./media/image8.png" width="221" height="27" />

Если все расстояния не равны нулю и имеют одинаковый знак, то треугольник T<sub>1</sub> лежит по одну сторону от плоскости π<sub>2</sub>, и пересечение отклоняется. То же самое делается для треугольника T<sub>2</sub> и плоскости π<sub>1</sub>. Два ранних теста позволяют отсечь множество пар треугольников от анализа на пересечение.

Если все расстояния равны 0, то треугольники компланарны. Если нет, то пересечение π<sub>1</sub> и π<sub>2</sub> – линия, L=O+t∙D, где D=N<sub>1</sub>×N<sub>2</sub> – направление линии, а O – точка на ней. Из-за предыдущих тестов можно гарантировать, что оба треугольника пересекают L. Эти пересечения формируют интервалы на линии L, и если эти интервалы перекрываются, то треугольники также пересекаются. Две ситуации, которые могут произойти, показаны на рис.7

| <img src="./media/image9.png" width="514" height="203" /> |
|-----------------------------------------------------------|
| Рис. 7. |

Предположим, что мы хотим вычислить скалярный интервал (на L), который является пересечением между T<sub>1</sub> и L, и, например, V<sub>0</sub><sup>1\\\\ </sup>и V<sub>2</sub><sup>1</sup> лежат на одной стороне от плоскости π<sub>2</sub> , а V<sub>1</sub><sup>1</sup> – на другой. Чтобы найти скалярные величины, которые представляют пересечение между ребрами V<sub>0</sub><sup>1</sup> V<sub>1</sub><sup>1</sup> и V<sub>1</sub><sup>1</sup> V<sub>2</sub><sup>1</sup> и L, вершины сначала проецируются на L:

<img src="./media/image10.png" width="145" height="30" />

Геометрия представлена на Рис.8.

| <img src="./media/image11.png" width="508" height="299" /> |
|------------------------------------------------------------|
| Рис.8. |

Затем мы вычисляем значение линейного параметра t<sub>1</sub> для B= V<sub>0</sub><sup>1</sup> V<sub>1</sub><sup>1</sup>∩L=O+t<sub>1</sub>∙D. K<sub>i</sub><sup>1</sup> обозначают проекцию V<sub>i</sub><sup>1</sup> на плоскость π<sub>2.</sub> Можно заметить, что <img src="./media/image12.png" width="67" height="20" /> подобен <img src="./media/image13.png" width="65" height="16" />, тогда

<img src="./media/image14.png" width="238" height="54" />

Такие же вычисления проводятся для параметра t<sub>2.</sub>

Этапы алгоритма:

1.  Вычислить уравнение треугольника 2.

2.  Проверить, не лежат ли все точки треугольника 1 с одной стороны.

3.  Вычислить уравнение треугольника 1.

4.  Проверить, не лежат ли все точки треугольника 2 с одной стороны.

5.  Вычислить линию пересечения и проецировать вершины на оси.

6.  Вычислить интервалы для каждого треугольника.

7.  Пересечь интервалы.

### **3.2 [Алгоритм Гига и Девиллера(2004)](https://github.com/ResidentTGT/Doc/blob/master/faster%20tr-tr%20intersection%20tests%20by%20Devillers%20and%20Guigue.pdf)**

Гиг и Девиллер предлагают новую формулировку предиката (геометрического теста) пересечения двух треугольников в трехмерном пространстве. Предикат – это часть кода, которая решает базовый вопрос геометрии. Эта формулировка может быть разбита на маленькое число трехмерных ориентационных тестов. Это большое преимущество по сравнению с реализацией этих предикатов у Мёллера и Хельда.

Каждая вершина каждого треугольника классифицируется по отношению к другим треугольникам, используя предикаты.

| <img src="./media/image15.png" width="515" height="348" /> |
|------------------------------------------------------------|
| Рис.9. |

Как и Мёллер, они начинают с проверки взаимного пересечения каждого треугольника с плоскостью другого. Треугольник 1 тестируется на пересечение с плоскостью 2.Для этого алгоритм классифицирует вершины тр.1 по отношению к плоскости 2 простым сравнением знаков трех определителей  <img src="./media/image16.png" width="169" height="19" /> и <img src="./media/image17.png" width="75" height="17" />. Пример такого определителя:<img src="./media/image18.png" width="327" height="143" />

Возможны три различные ситуации:

1) три определителя одинакового знака и ни один из них не равен 0

2) все три определителя равны 0

3) определители имеют разные знаки

Случай 1 происходит, когда все три вершины тр.1 лежат по 1 сторону от пл.2. Случай 2 происходит, когда треугольники компланарны и определяют одну и ту же плоскость. Случай 3 происходит, когда вершины треугольника 1 лежат по разные стороны от плоскости 2 и тр.1. пересекает пл.2. Затем также проверяется пересечение тр.2 и пл.1.

Далее алгоритм применяет круговые перестановки вершин треугольников, чтобы только одна точка тр.1 p<sub>1</sub> лежала на одной из сторон пл. 2. Дополнительная перестановка выполняется одновременно с вершинами q<sub>2</sub> и r<sub>2</sub>, чтобы точка p<sub>1</sub> соответствовала положительной стороне пл. 2.

Из-за предыдущих перестановок, рёбра, исходящие из точек p<sub>1</sub> и p<sub>2</sub> гарантированно пересекают L в уникальной точке. Пусть i, j, k, l будут точками пересечения L с ребрами p<sub>1</sub>r<sub>1</sub>, p<sub>1</sub>q<sub>1</sub>, p<sub>2</sub>q<sub>2,</sub> p<sub>2</sub>r<sub>2</sub> соответственно. Эти пересечения формируют интервалы I<sub>1</sub>и I<sub>2</sub> на L, которые соответствуют пересечению между двумя треугольниками и L. На данном этапе уже есть достаточно информации для того, чтобы знать последовательный порядок связей каждого интервала. I<sub>1</sub>= \[I, j\], I<sub>2</sub>= \[k, l\], если L ориентирована по направляющей N= N<sub>1</sub>×N<sub>2</sub>, где N<sub>1</sub>=(q<sub>1</sub>-p<sub>1</sub>) ×(r<sub>1</sub>-p<sub>1</sub>), N<sub>2</sub>=(q<sub>2</sub>-p<sub>2</sub>) ×(r<sub>2</sub>-p<sub>2</sub>). Теперь надо проверить условие минимума и максимума, чтобы узнать, перекрываются интервалы или нет. Это условие означает, что минимум одного интервала должен быть меньше, чем максимум другого, k≤ j, i≤ l. Это условие также сводится к проверке предикатов

<img src="./media/image19.png" width="434" height="26" />

Подводя итоги, этапы данного алгоритма следующие.

1.  Определяются позиции вершин тр.1 по отношению к пл.2. и проводят тривиальную проверку на нахождение всех вершин тр.1 по одну сторону от пл.2.

2.  То же самое делается с вершинами тр.2 и пл.1.

3.  Сравнивают все знаки для определения правильной перестановки вершин каждого треугольника и проверяют два неравенства (1).

| <img src="./media/image20.png" width="618" height="321" /> |
|------------------------------------------------------------|
| Рис.10.Символьное представление пересечения |

### **3.3 [Алгоритм Троппа и Шимшони(2005)](https://github.com/ResidentTGT/Doc/blob/master/fast%20triangle%20to%20triangle%20intersection%20test%20for%20collision%20detection(Shinshoni).pdf)**

Метод основан на алгоритме полного перебора. Их главное наблюдение состоит в том, что наборы уравнений сильно взаимосвязаны. Т. о., используя линейность операций с матрицами, общие элементы разных уравнений могут быть заново использованы для ускорения решения. Хотя их алгоритм фокусируется на проблеме обнаружения столкновений, их алгоритм может быть применен к другим задачам схожей природы, где требуется решение группы систем уравнений типа Ax=b, где величины A и b линейно зависимы в разных наборах. В этом алгоритме выполняется меньшее количество арифметических операций(95-97), нежели в алгоритмах Мёллера (126-148) и Гига и Девиллера (114-144).

Пусть треугольники A и B находятся в трехмерном пространстве. 

| <img src="./media/image21.png" width="544" height="231" /> |
|------------------------------------------------------------|
| Рис. 11. |

Если они пересекаются, то ребра одного треугольника пересекают поверхность другого. Пусть p<sub>1</sub> и p<sub>2</sub>- ребра треугольника B, имеющие общую вершину P, а q<sub>i</sub> (1≤i≤3) –ребра треугольника А, исходящие из соответствующих вершин Q<sub>i</sub>. Чтобы найти точку пересечения между плоскостью, определённой p<sub>1</sub> и p<sub>2</sub>, и ребром q<sub>i</sub>, надо решить систему уравнений:

<img src="./media/image22.png" width="273" height="29" />(1)

Для того чтобы точка пересечения находилась внутри треугольника, решение этих уравнений должно удовлетворять следующим условиям: 0≤β<sub>i</sub>≤1, α<sub>1</sub>, α<sub>2</sub>≥0, α<sub>1</sub>+ α<sub>2</sub>≤1

Должно быть выполнено шесть подобных тестов пересечений: три для проверки треугольника А с ребрами треугольника B и три для проверки треугольника B с ребрами треугольника A. Основная идея их алгоритма – это сокращение числа арифметических операций благодаря использованию общих элементов и линейности матричных операций.

Алгоритм начинается с того, что решается три набора уравнений, в которых находятся β<sub>i</sub>. Эти наборы соответствуют пересечениям трех ребер треугольника А с плоскостью треугольника B (уравнение 1). При некоторых значениях β<sub>i</sub> пересечение сразу отрицается. Значения β<sub>i</sub> используются, чтобы построить линейный сегмент пересечения между A и плоскостью B (t на Рис. 1). Любое пересечение между треугольниками должно лежать на этой линии. Таким образом, проблема сведена к определению плоского пересечения между этим сегментом и треугольником B.

Алгоритм состоит из пяти этапов:

1.  Нахождение параметров β<sub>i</sub>, 1≤i≤3 используя определители.

2.  Если β<sub>i</sub> не найдены или не удовлетворяют условию 0≤β<sub>i</sub>≤1 сделать вывод, что пересечения нет.

3.  Построить сегмент пересечения между треугольником A и плоскостью B.

4.  Если этот сегмент пересекает треугольник B, то треугольники пересекаются.

5.  Построить сегмент пересечения между двумя треугольниками

<img src="./media/image23.png" width="623" height="261" />

| <img src="./media/image24.png" width="623" height="120" /> |
|------------------------------------------------------------|
| Рис.12. |
